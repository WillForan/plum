#!/usr/bin/env perl
use strict; use warnings;
use v5.28;
use feature qw(signatures);
no warnings qw(experimental::signatures experimental::smartmatch);

# quick print of whats going on
our $DEBUG=0;
sub debug($msg, $level) { say "DEBUG($level): $msg" if $DEBUG >= $level; }

#
# Parse psuedo-plumb(7) (plan9port) plumber files
# requires ps, xdotool, xclip
#

# e.g.
#
#  # open http or https in a browser
#  text matches ^https?://
#  start xdg-open $text
#
#  # use ctrl+c clipboard to convert images when in inkscape
#  from secondary
#  text matches ^(\s+).(jpe?g|gif|ppm)$
#  add base=$1 ext=$2
#  app matches inkscape
#  start convert $text $base.png

####
# format: paragraphs (2x\n delimited) with
#
#  {text,cwd,app,title} matches REGEXP
#  add myvar=$1
#  plum PROGRAM $cwd $myvar 

# where
# * 'text' is the text on the clipboard
# * 'cwd' is current working directory
# * 'app' is the application focused
# and keywords 
#  * from      -- which clipboard
#  * matches   -- regexp
#  * add       -- create variable
#  * start     -- launch program (from cwd of X11 app)


# find what it is we are told to (file or folder)
# are there other objects? should we abstract this more?
# TODO: how do we call '-f' as a variable? 
sub isfile($search, $textInfo) {
   return($search) if( -e -r -f $search);
   # try glob
   my @g = glob($search);
   return($g[0]) if($#g == 0 && -e -r -f $g[0]);
   # nothing matches
   return("");
}
sub isdir($search, $textInfo) {
   return($search) if( -e -r -d $search);
   # try glob
   my @g = glob($search);
   return($g[0]) if($#g == 0 && -e -r -d $g[0]);
   # nothing matches
   return("");
}
# functions get called by looking up from matched string
our %loc = ( 'file' => \&isfile, 'dir' => \&isdir);


sub cmd_from_section($INFH, $textInfo) {
   my @matches = (); # reg exp matches
   my $cmd = "";
   while($_=<$INFH>) {
      chomp;
      debug("section readline: $_",3);
      s/ #.*//;
      
      given($_) {
         when(/^\s*#/) {
            debug("skipping comment $_", 1);
            next;
         }
         when(m/^from (\w+)/) {
            $textInfo->{'text'}=`xclip -o $1`;
         }
         when(m/^(text|cwd|app|) matches (.*)/) {
            debug("matching $2 against $1: $textInfo->{$1}", 1);
            my $re = qr/$2/;
            @matches = ($textInfo->{$1} =~ /$re/);
            # if no matches, we dont do anything
            debug("no matches '$_'", 1) if $#matches < 0;
            last if $#matches < 0;
         }
         when(m/^add (.*)/){
            while( m/(\w+)=\$(\d+)/g) {
               $textInfo->{$1} = $matches[$2-1];
               debug("added $1 = ". $matches[$2-1],1);
            }
         }
         # add file or dir to the textInfo hash or rule doesn't match
         when(m/^arg is(file|dir) (.*)/){
            my $f_or_d=$1;
            my $totest=$2;
            $totest =~ s/\$(\w+)/$textInfo->{$1}/ge;
            $textInfo->{$f_or_d} = $loc{$f_or_d}->($totest, $textInfo);
            # if lookup failed, get out of here
            last if ! $textInfo->{$f_or_d};
            debug("added $1 = ". $matches[$2-1], 1);
         }
         # replace command with anything we've stored
         when(m/^start (.*)/){
            $cmd="$1";
            $cmd =~ s/\$(\w+)/$textInfo->{$1}/ge;
         }
         when(m/^$/){
            last;
         }
         default {
            debug("section: line not understood: $_",0);
            last
         }
      }
  }
     
  # read up to the next section
  until(/^$/){ $_=<$INFH>; }
  #until(/^$/ or eof($INFH)){ $_=<$INFH>; } 
  # inline::files eof() not supported
  return $cmd;
}

# get title, app, and clipboard text
sub setup_info() {
   my $textInfo = {};
   # xdotool to get pid
   chomp(my $wpid=`xdotool getwindowfocus getwindowpid`);
   debug("wpid: $wpid",1);

   # grab last entry from ps, take only the first word
   chomp(my $psapp = (split(/\n/, `ps -o comm,args -p $wpid`))[-1]);
	$textInfo->{app}=(split(/\s+/, $psapp))[0];
   debug("app: $textInfo->{app}",1);

   # use xdotool to get window
   chomp($textInfo->{title} = `xdotool getactivewindow getwindowname`);
   debug("title: $textInfo->{title}",1);

   # fetch clipboard
   # TODO: use perl lib for cross platform? will require cpanm install
   $textInfo->{text} = `xclip -o`;
   debug("text: $textInfo->{text}",1);
   return($textInfo);
}

# TODO: config file provides regexp for getting cwd
sub cwd_rules($INFH){
   while($_=<$INFH>){
      debug("cwd_rules readline: $_",3);
      if( m/parse cwd (\S+) (\S+) (\S+)/){
         debug('parse cwd not implemented yet!', 0);
         next;
      }
   }
}
#
# 
sub read_config($INFH, $textInfo){
   my $cmd = "";
   while(!eof($INFH)){
      # define ways to parse cwd given program regexp, title regexp, reconstruction
      $cmd=cmd_from_section($INFH, $textInfo);
      # read read of lines from failed command parse
      return($cmd) if $cmd;
   };
   # empty string if no command found
   return("")
}

# protect execution from test code
# -- only run if e.g. ./plum
unless(caller){
   my $textInfo = setup_info();
   my $fh;
   foreach my $f ("$ENV{HOME}/.config/plum.conf","/etc/plum.conf", "./plum.conf") {
     debug("testing $f",3);
     next unless -e $f;
     open($fh, '<', $f) or die "cannot open $f";
     debug("using $f",1);
   }
   if(not $fh){
     $fh=*DATA if not $fh;
     debug("using built in plumbing",1);
   }
   my $cmd=read_config($fh, $textInfo);
   if($cmd eq ""){
      debug("no matching commands for '$textInfo->{text}'",1);
      exit(1);
   }

   debug("exec $cmd",3);
   exec $cmd;
}

__DATA__
# open http or https in a browser
text matches ^https?://.*
text matches hangouts
start chromium $text


text matches ^https?://.*
start xdg-open $text

# use ctrl+c clipboard to convert images when in inkscape
from secondary
text matches ^(\s+).(jpe?g|gif|ppm)$
add base=$1 ext=$2
app matches inkscape
start convert $text $base.png

